#######################################################
# Download GBIF occurrences for DVW priority species
# Date: Sys.Date()
# 
# This script downloads GBIF occurrence data for Belgium
# for all species on the DVW checklist, including Zizania latifolia.
# The result is saved, unzipped, and prepared for downstream processing.
#######################################################

# Load required libraries
library(tidyverse)      # Data manipulation
library(here)           # File paths
library(rgbif)          # GBIF API
library(lubridate)      # Date handling
library(sf)
library(dplyr)


# ------------------------------------------------------------------
# 1. Define query parameters
# ------------------------------------------------------------------

# GBIF dataset key for the DVW checklist
datasetKey <- "23e95da2-6095-4778-b893-9af18a310cb6"

# Retrieve checklist data
DVW_list <- name_usage(datasetKey = datasetKey)

# Filter species from the checklist
species_list <- DVW_list$data %>%
  filter(origin == "SOURCE")

# Add one manually-resolved species
Zizania <- name_backbone("Zizania latifolia")

# Combine species keys
species_keys <- species_list$nubKey %>%
  append(Zizania$speciesKey)

# Define filters
hasCoordinate <- TRUE


# ------------------------------------------------------------------
# 2. Trigger GBIF download request
# ------------------------------------------------------------------

gbif_download_key <- occ_download(
  pred_in("taxonKey", species_keys),
  pred("country", "BE"),
  pred_gte("year", 2013),
  pred("hasCoordinate", hasCoordinate),
  pred("occurrenceStatus", "present"),
  format = "SIMPLE_CSV",
  user = rstudioapi::askForPassword("GBIF username"),
  pwd = rstudioapi::askForPassword("GBIF password"),
  email = rstudioapi::askForPassword("Email address for notification")
)

# Check initial download status
metadata <- occ_download_meta(key = gbif_download_key)
cat("Download Key:", metadata$key, "\n")
cat("Download Status:", metadata$status, "\n")

# ------------------------------------------------------------------
# 3. Wait until GBIF download is ready
# ------------------------------------------------------------------

download_key <- gbif_download_key
output_dir <- here("data", "input", "raw")
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

max_tries <- 60        # Max retries
interval_sec <- 60     # Time between retries in seconds

cat("Download gestart voor sleutel:", download_key, "\n")

for (i in 1:max_tries) {
  meta <- occ_download_meta(download_key)
  status <- meta$status
  
  cat("Check", i, "- Status:", status, "\n")
  
  if (status == "SUCCEEDED") {
    cat("Download voltooid. Ophalen gestart...\n")
    break
  } else if (status %in% c("KILLED", "CANCELLED", "FAILED")) {
    stop("Download afgebroken of mislukt: ", status)
  } else {
    Sys.sleep(interval_sec)
  }
  
  if (i == max_tries) stop("Download niet voltooid binnen de voorziene tijd.")
}

# ------------------------------------------------------------------
# 4. Download ZIP file and extract
# ------------------------------------------------------------------

# Define consistent filename for archive
dest_file <- file.path(output_dir, paste0("gbif_download_", Sys.Date(), "_", download_key, ".zip"))
occ_download_get(download_key, path = output_dir, overwrite = TRUE)

# Rename the downloaded file
file.rename(file.path(output_dir, paste0(download_key, ".zip")), dest_file)
cat("Download opgeslagen als:", dest_file, "\n")

# Unzip into subfolder named after download key
unzipped_dir <- file.path(output_dir, download_key)
dir.create(unzipped_dir, showWarnings = FALSE, recursive = TRUE)

unzip(dest_file, exdir = unzipped_dir)
cat("Bestand uitgepakt naar:", unzipped_dir, "\n")

# Delete original ZIP archive
file.remove(dest_file)
cat("ZIP-bestand verwijderd:", dest_file, "\n")

### READ CSV 

# Pad naar uitgepakte downloadmap
unzipped_dir <- file.path(output_dir, download_key)

# Zoek naar occurrence-bestand
csv_file <- list.files(unzipped_dir, pattern = "\\.csv$|occurrence\\.txt$", full.names = TRUE)

if (length(csv_file) == 0) {
  stop("Geen occurrence-bestand gevonden in: ", unzipped_dir)
}

# Lees bestand in
gbif_data <- read_tsv(csv_file[1], show_col_types = FALSE)

cat("Ingelezen GBIF-data met", nrow(gbif_data), "records uit:\n", csv_file[1], "\n")



# Controleer eerst dat er geen NA's in de coördinaten zitten
gbif_data_clean <- gbif_data %>%
  filter(!is.na(decimalLongitude), !is.na(decimalLatitude))

# Zet om naar sf
gbif_sf <- st_as_sf(
  gbif_data_clean,
  coords = c("decimalLongitude", "decimalLatitude"),
  crs = 4326,       # GBIF-coördinaten zijn standaard in WGS84 (EPSG:4326)
  remove = FALSE    # Laat de originele coördinatenkolommen staan
)

# Transformeer naar Lambert
gbif_sf_l72 <- st_transform(gbif_sf, 31370)



# Resultaat bekijken
print(gbif_sf)


# --- 5. Inlezen shapefiles uit data/input/ ---

input_path <- "./data/input"
dvw_indeling <- st_read(file.path(input_path, "DVW_indeling.gpkg")) %>% st_transform(31370)
dvw_percelen <- st_read(file.path(input_path, "DVW_percelen.gpkg")) %>% st_transform(31370)

# --- 6. Intersecties ---

# Indexeer en neem intersect

idx_kern <- st_intersects(gbif_sf_l72, dvw_indeling)
EWS_kern <- gbif_sf_l72[lengths(idx_kern) > 0, ]

idx_percelen <- st_intersects(gbif_sf_l72, dvw_percelen)
EWS_percelen <- gbif_sf_l72[lengths(idx_percelen) > 0, ]


# ------------------------------------------------------------------
# 7. Vergelijk met vorige download (indien beschikbaar)
# ------------------------------------------------------------------

# Zoek afzonderlijk de laatst opgeslagen versies van kern en percelen
kern_files <- list.files(output_dir, pattern = "EWS_kern_.*\\.gpkg$", full.names = TRUE)
percelen_files <- list.files(output_dir, pattern = "EWS_percelen_.*\\.gpkg$", full.names = TRUE)

if (length(kern_files) > 0 & length(percelen_files) > 0) {
  message("Vorige datasets gevonden, laad laatste versies in...")
  
  # Laad enkel de meest recente bestanden
  last_kern <- kern_files[which.max(file.mtime(kern_files))]
  last_percelen <- percelen_files[which.max(file.mtime(percelen_files))]
  
  EWS_kern_old <- st_read(last_kern, quiet = TRUE)
  EWS_percelen_old <- st_read(last_percelen, quiet = TRUE)
  
  # Zet IDs als character om mismatch te vermijden
  EWS_kern_old$gbifID <- as.character(EWS_kern_old$gbifID)
  EWS_percelen_old$gbifID <- as.character(EWS_percelen_old$gbifID)
  
  EWS_kern$gbifID <- as.character(EWS_kern$gbifID)
  EWS_percelen$gbifID <- as.character(EWS_percelen$gbifID)
  
  # Label nieuwe records (op basis van gbifID)
  EWS_kern$nieuw <- !(EWS_kern$gbifID %in% EWS_kern_old$gbifID)
  EWS_percelen$nieuw <- !(EWS_percelen$gbifID %in% EWS_percelen_old$gbifID)
  
} else {
  message("Geen oude datasets gevonden, markeer alles als nieuw.")
  EWS_kern$nieuw <- TRUE
  EWS_percelen$nieuw <- TRUE
}




# Opslaan huidige versies (om volgende keer te vergelijken)
st_write(EWS_kern, file.path(output_dir, paste0("EWS_kern_", Sys.Date(), ".gpkg")), delete_dsn = TRUE)
st_write(EWS_percelen, file.path(output_dir, paste0("EWS_percelen_", Sys.Date(), ".gpkg")), delete_dsn = TRUE)



# 11. Visualisatie
layers <- list(
  EWS_kern = EWS_kern,
  EWS_percelen = EWS_percelen,
  dvw_indeling = dvw_indeling,
  dvw_percelen = dvw_percelen
)
layers_wgs <- lapply(layers, st_transform, crs = 4326)

leaflet() %>%
  addProviderTiles("CartoDB.Positron") %>%
  
  addPolygons(data = layers_wgs$dvw_indeling, color = "#999999", weight = 1, fillOpacity = 0.2, group = "DVW Indeling") %>%
  addPolygons(data = layers_wgs$dvw_percelen, color = "#666666", weight = 1, fillOpacity = 0.2, group = "DVW Percelen") %>%
  
  # EWS Kern: oud
  addCircleMarkers(data = layers_wgs$EWS_kern[!layers$EWS_kern$nieuw, ],
                   radius = 4, stroke = FALSE, fillColor = "#3182bd", fillOpacity = 0.7, group = "EWS Kern") %>%
  # EWS Kern: nieuw
  addCircleMarkers(data = layers_wgs$EWS_kern[layers$EWS_kern$nieuw, ],
                   radius = 4, stroke = FALSE, fillColor = "#006400", fillOpacity = 0.9, group = "Nieuwe Kern") %>%
  
  # EWS Percelen: oud
  addCircleMarkers(data = layers_wgs$EWS_percelen[!layers$EWS_percelen$nieuw, ],
                   radius = 4, stroke = TRUE, color = "#e41a1c", weight = 1, fillOpacity = 1, group = "EWS Percelen") %>%
  # EWS Percelen: nieuw
  addCircleMarkers(data = layers_wgs$EWS_percelen[layers$EWS_percelen$nieuw, ],
                   radius = 4, stroke = TRUE, color = "#ADFF2F", weight = 1, fillOpacity = 1, group = "Nieuwe Percelen") %>%
  
  addLayersControl(
    overlayGroups = c("EWS Percelen", "Nieuwe Percelen", "EWS Kern", "Nieuwe Kern", "DVW Indeling", "DVW Percelen"),
    options = layersControlOptions(collapsed = FALSE)
  )

